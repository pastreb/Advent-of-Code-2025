import os.path
import re

def read_input(input_file_name):
    input_file = os.path.join(os.path.dirname(__file__), input_file_name)
    with open(input_file, "r") as f:
        lines = f.readlines()
        return lines

# --- Day 7: Laboratories ---

# You thank the cephalopods for the help and exit the trash compactor, 
# finding yourself in the familiar halls of a North Pole research wing.

# Based on the large sign that says "teleporter hub", they seem to be 
# researching teleportation; you can't help but try it for yourself and step 
# onto the large yellow teleporter pad.

# Suddenly, you find yourself in an unfamiliar room! The room has no doors; 
# the only way out is the teleporter. Unfortunately, the teleporter seems to 
# be leaking magic smoke.

# Since this is a teleporter lab, there are lots of spare parts, manuals, and 
# diagnostic equipment lying around. After connecting one of the diagnostic 
# tools, it helpfully displays error code 0H-N0, which apparently means that 
# there's an issue with one of the tachyon manifolds.

# You quickly locate a diagram of the tachyon manifold (your puzzle input). A 
# tachyon beam enters the manifold at the location marked S; tachyon beams 
# always move downward. Tachyon beams pass freely through empty space (.). 
# However, if a tachyon beam encounters a splitter (^), the beam is stopped; 
# instead, a new tachyon beam continues from the immediate left and from the 
# immediate right of the splitter.

# For example:

# .......S.......
# ...............
# .......^.......
# ...............
# ......^.^......
# ...............
# .....^.^.^.....
# ...............
# ....^.^...^....
# ...............
# ...^.^...^.^...
# ...............
# ..^...^.....^..
# ...............
# .^.^.^.^.^...^.
# ...............

# In this example, the incoming tachyon beam (|) extends downward from S 
# until it reaches the first splitter:

# .......S.......
# .......|.......
# .......^.......
# ...............
# ......^.^......
# ...............
# .....^.^.^.....
# ...............
# ....^.^...^....
# ...............
# ...^.^...^.^...
# ...............
# ..^...^.....^..
# ...............
# .^.^.^.^.^...^.
# ...............

# At that point, the original beam stops, and two new beams are emitted from 
# the splitter:

# .......S.......
# .......|.......
# ......|^|......
# ...............
# ......^.^......
# ...............
# .....^.^.^.....
# ...............
# ....^.^...^....
# ...............
# ...^.^...^.^...
# ...............
# ..^...^.....^..
# ...............
# .^.^.^.^.^...^.
# ...............

# Those beams continue downward until they reach more splitters:

# .......S.......
# .......|.......
# ......|^|......
# ......|.|......
# ......^.^......
# ...............
# .....^.^.^.....
# ...............
# ....^.^...^....
# ...............
# ...^.^...^.^...
# ...............
# ..^...^.....^..
# ...............
# .^.^.^.^.^...^.
# ...............

# At this point, the two splitters create a total of only three tachyon 
# beams, since they are both dumping tachyons into the same place between 
# them:

# .......S.......
# .......|.......
# ......|^|......
# ......|.|......
# .....|^|^|.....
# ...............
# .....^.^.^.....
# ...............
# ....^.^...^....
# ...............
# ...^.^...^.^...
# ...............
# ..^...^.....^..
# ...............
# .^.^.^.^.^...^.
# ...............

# This process continues until all of the tachyon beams reach a splitter or 
# exit the manifold:

# .......S.......
# .......|.......
# ......|^|......
# ......|.|......
# .....|^|^|.....
# .....|.|.|.....
# ....|^|^|^|....
# ....|.|.|.|....
# ...|^|^|||^|...
# ...|.|.|||.|...
# ..|^|^|||^|^|..
# ..|.|.|||.|.|..
# .|^|||^||.||^|.
# .|.|||.||.||.|.
# |^|^|^|^|^|||^|
# |.|.|.|.|.|||.|

# To repair the teleporter, you first need to understand the beam-splitting 
# properties of the tachyon manifold. In this example, a tachyon beam is 
# split a total of 21 times.

# Analyze your manifold diagram. How many times will the beam be split?

def print_map(map):
    for line in map:
        for x in line:
            print(x, end='')
        print("\n")

def compute_part_1(input_file_name="input.txt"):
    input = read_input(input_file_name)
    map = [[x for x in re.findall(r"S|\.|\^", line)] for line in input]
    n_splits = 0
    for l in range(1, len(map)):
        for i in range(len(map[l])):
            match map[l-1][i], map[l][i]:
                case "S", ".":
                    map[l][i] = '|'
                    continue
                case "|", '.':
                    map[l][i] = '|'
                    continue
                case "|", '^':
                    map[l][i-1] = "|"
                    map[l][i+1] = "|"
                    n_splits += 1
                    continue
    return n_splits

# 1626
# That's the right answer! You are one gold star closer to decorating the 
# North Pole.

# --- Part Two ---

# With your analysis of the manifold complete, you begin fixing the 
# teleporter. However, as you open the side of the teleporter to replace the 
# broken manifold, you are surprised to discover that it isn't a classical 
# tachyon manifold - it's a quantum tachyon manifold.

# With a quantum tachyon manifold, only a single tachyon particle is sent 
# through the manifold. A tachyon particle takes both the left and right path 
# of each splitter encountered.

# Since this is impossible, the manual recommends the many-worlds 
# interpretation of quantum tachyon splitting: each time a particle reaches a 
# splitter, it's actually time itself which splits. In one timeline, the 
# particle went left, and in the other timeline, the particle went right.

# To fix the manifold, what you really need to know is the number of 
# timelines active after a single particle completes all of its possible 
# journeys through the manifold.

# In the above example, there are many timelines. For instance, there's the 
# timeline where the particle always went left:

# .......S.......
# .......|.......
# ......|^.......
# ......|........
# .....|^.^......
# .....|.........
# ....|^.^.^.....
# ....|..........
# ...|^.^...^....
# ...|...........
# ..|^.^...^.^...
# ..|............
# .|^...^.....^..
# .|.............
# |^.^.^.^.^...^.
# |..............

# Or, there's the timeline where the particle alternated going left and right 
# at each splitter:

# .......S.......
# .......|.......
# ......|^.......
# ......|........
# ......^|^......
# .......|.......
# .....^|^.^.....
# ......|........
# ....^.^|..^....
# .......|.......
# ...^.^.|.^.^...
# .......|.......
# ..^...^|....^..
# .......|.......
# .^.^.^|^.^...^.
# ......|........

# Or, there's the timeline where the particle ends up at the same point as 
# the alternating timeline, but takes a totally different path to get there:

# .......S.......
# .......|.......
# ......|^.......
# ......|........
# .....|^.^......
# .....|.........
# ....|^.^.^.....
# ....|..........
# ....^|^...^....
# .....|.........
# ...^.^|..^.^...
# ......|........
# ..^..|^.....^..
# .....|.........
# .^.^.^|^.^...^.
# ......|........

# In this example, in total, the particle ends up on 40 different timelines.

# Apply the many-worlds interpretation of quantum tachyon splitting to your 
# manifold diagram. In total, how many different timelines would a single 
# tachyon particle end up on?

def compute_part_2(input_file_name="input.txt"):
    input = read_input(input_file_name)
    map = [[x for x in re.findall(r"S|\.|\^", line)] for line in input]
    n_timelines = {}
    for l in range(1, len(map)):
        for i in range(len(map[l])):
            match map[l-1][i], map[l][i]:
                case "S", ".":
                    map[l][i] = '|'
                    n_timelines[(l,i)] = 1
                    continue
                case "|", '.':
                    map[l][i] = '|'
                    n_timelines[(l,i)] = n_timelines[(l-1,i)]
                    continue
                case "|", "|":
                    n_timelines[(l,i)] = n_timelines.get((l,i), 0) + n_timelines[(l-1,i)]
                case "|", '^':
                    map[l][i-1] = "|"
                    n_timelines[(l,i-1)] = n_timelines.get((l,i-1), 0) + n_timelines[(l-1,i)]
                    map[l][i+1] = "|"
                    n_timelines[(l,i+1)] = n_timelines.get((l,i+1), 0) + n_timelines[(l-1,i)]
                    continue
    total_n_timelines = sum([n_timelines.get((len(map)-1, i), 0) for i in range(len(map[0]))])
    return total_n_timelines

# 48989920237096
# That's the right answer! You are one gold star closer to decorating the 
# North Pole.

if __name__ == "__main__":
    print(f"PART 1: {compute_part_1()}")
    print(f"PART 2: {compute_part_2()}")
